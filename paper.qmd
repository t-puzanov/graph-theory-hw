---
title: "BFS-дерево"
author: "Пузанов Тамир, группа 23122"
toc: true
format:
  html:
    theme: cosmo
    fontsize: 1.1em
    linestretch: 1.7
    html-math-method: katex
    code-tools: true
    self-contained: true
execute:
  warning: false
---

# Алгоритм поиска в ширину

Алгоритм **поиска в ширину** (BFS, Breadth First Search) это алгоритм
обхода графа, работа которого заключается в последовательном **посещении** вершин 
и исследовании ребер. Какие именно действия выполняются при посещении вершины 
и исследовании ребра – зависит от задачи, для решения которой производится обход. 
В частности, алгоритм BFS используется для построения каркасов (BFS-деревьев).

## Процедура BFS

Идея поиска в ширину состоит в том, чтобы посещать вершины в порядке 
их удаленности от некоторой заранее выбранной стартовой вершины $a$. 
Иначе говоря, сначала посещается сама вершина $a$, затем все вершины, 
смежные с $a$, то есть находящиеся от нее на расстоянии $1$, затем вершины, 
находящиеся от $a$ на расстоянии $2$, и т.д. 

При обходе, факт посещения вершины запоминается, так что с момента
посещения и до конца работы алгоритма она считается **посещенной**. 
Вершину, которая еще не посещена, будем называть **новой**. В результате посещения 
вершина становится **открытой** и остается такой, пока не будут исследованы все 
инцидентные ей ребра. После этого она превращается в **закрытую**.

Пусть $V(x)$ – это множество всех вершин, смежных с $x$, а $Q$ – очередь из вершин.
Напомним, что все элементы в очереди упорядочены. Элементы добавляются в конец,
а извлекаются с начала очереди. При извлечении элемент удаляется.

```
1 :  посетить вершину a
2 :  a ⇒ Q
3 :  while Q ≠ ∅ do
4 :      x ⇐ Q
5 :      for y ∈ V(x) do
6 :          исследовать ребро (x, y)
7 :          if вершина y новая then
8 :              посетить вершину y
9 :              y ⇒ Q
```

Вначале все вершины помечаются как новые. Первой посещается вершина $a$, 
она становится единственной открытой вершиной. В дальнейшем каждый очередной шаг
начинается с выбора некоторой открытой вершины $x$. Эта вершина становится активной. 
Далее исследуются ребра, инцидентные активной вершине. Если такое ребро соединяет вершину $x$ с
новой вершиной $y$, то вершина $y$ посещается и превращается в открытую. Когда все ребра, 
инцидентные активной вершине, исследованы, она перестает быть активной и становится закрытой. 
После этого выбирается новая активная вершина, и описанные действия повторяются. 
Процесс заканчивается, когда множество открытых вершин становится пустым. 

## Свойства процедуры BFS

1. Процедура BFS заканчивает работу после конечного числа шагов;

2. В результате выполнения процедуры BFS будут посещены все вершины 
из компоненты связности, содержащей вершину $a$, и только они;

3. Время работы процедуры BFS есть $O(m)$, где $m$ – число ребер в
компоненте связности, содержащей вершину $a$;

4. Чем ближе вершина находится к вершине $a$, тем раньше она будет посещена.


# Построение каркаса связного графа методом поиска в ширину

Ребра, исследуемые в процессе обхода графа, можно разделить на две
категории: если ребро соединяет активную вершину $x$ с новой вершиной
$y$, то оно классифицируется как **прямое**, в противном случае – как **обратное**.

Предположим, что алгоритм поиска в ширину применяется к связному
графу. Тогда по окончании обхода множество всех прямых ребер образует дерево.

Такое дерево называется BFS-деревом. Любое BFS-дерево является **геодезическим деревом**, т.е.
деревом, в котором для любой вершины $x$ путь из $x$ в $a$ в дереве является **кратчайшим путем**
между $x$ и $a$ в исходном графе.

## Описание алгоритма

Пусть $Q$ – очередь, $T$ – множество прямых ребер и $B$ – множество обратных.
В процессе обхода будем помечать ребра, добавляя их в соответсвующие множества. 
Можно присвоить всем вершинам их глубинные номера $\text{Dnum}(v)$, 
определяемые в порядке их встречи при обходе.

**Шаг 1.** $T := \emptyset, B := \emptyset, Q := \{v_0\}, \text{Dnum}(v_0) := 1, k := 1$;

**Шаг 2.** Если $Q = \emptyset$, то конец, иначе $x$ ⇐ $Q$ (вершина $x$ 
становится активной, при извлечении элемент удаляется из очереди);

**Шаг 3.** Если все ребра при $x$ лежат в $T \cup B$, то $x$ становится закрытой, 
поэтому перейти на шаг 2, иначе выбрать такую вершину $y$ смежную с $x$, что $(x, y) \notin T \cup B$, $e := (x, y)$;

**Шаг 4.** Если $\exists \ \text{Dnum}(y)$, то ребро $e$ соединяет активную вершину
с уже открытой, поэтому $e$ ⇒ $B$ и перейти на шаг 3; Иначе $y$ является новой вершиной, 
поэтому $e$ ⇒ $T$, $y$ ⇒ $Q$, $k := k + 1$, $\text{Dnum}(y) := k$ и перейти на шаг 3.

В результате работы алгоритма множество $T$ будет содержать ребра, образующие BFS-дерево,
каркас исходного связного графа.

## Код на Python

```{python}
from collections import deque

def bfs_tree(n, adjacency_matrix, a):
    """
    Построение BFS-дерева для связного неориентированного графа,
    заданного матрицей смежности.

    Параметры:
        n: int — число вершин графа
        adjacency_matrix: List[List[int]] — матрица смежности (0/1)
        a: int — стартовая вершина (индекс от 0 до n-1)

    Возвращает:
        T: set — множество прямых рёбер (рёбер BFS-дерева)
        B: set — множество обратных рёбер
        Dnum: dict — глубинные номера вершин в порядке их посещения
    """
    # ------- Шаг 1: инициализация -------
    Q = deque()                 # Очередь открытых вершин
    T = set()                   # Множество прямых рёбер (рёбер BFS-дерева)
    B = set()                   # Множество обратных рёбер
    Dnum = dict()               # Словарь глубинных номеров
    k = 1                       # Счётчик порядка посещения
    Dnum[a] = 1                 # Присвоить стартовой вершине номер 1
    Q.append(a)                 # Добавить стартовую вершину в очередь

    # ------- Основной цикл обхода -------
    while len(Q) != 0:
        # ------- Шаг 2: извлечение активной вершины -------
        x = Q.popleft()         # x становится активной вершиной

        # ------- Шаг 3: перебор всех смежных вершин -------
        for y in range(n):
            # Пропустить, если нет ребра между x и y
            if adjacency_matrix[x][y] == 0:
                continue

            # Нормализуем ребро
            e = (min(x, y), max(x, y))

            # Пропустить, если ребро уже было обработано (уже в T или B)
            if e in T or e in B:
                continue

            # ------- Шаг 4: классификация ребра -------
            if y in Dnum:
                # y уже была посещена, поэтому ребро (x, y) — обратное
                B.add(e)
            else:
                # y — новая вершина, поэтому ребро (x, y) — прямое
                T.add(e)                # Добавить в каркас
                Q.append(y)             # Открыть вершину y
                k += 1                  # Увеличить счётчик посещений
                Dnum[y] = k             # Присвоить глубинный номер

        # После обработки всех рёбер при x, x становится закрытой.
        # Цикл автоматически переходит к следующей вершине в очереди (Шаг 2).

    # Конец
    return T, B, Dnum
```

### Тесты

Код был проверен на 12-ти примерах. См. файл `test.py`
