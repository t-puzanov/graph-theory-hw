from collections import deque


def bfs_tree(n, adjacency_matrix, a):
    """
    Построение BFS-дерева для связного неориентированного графа,
    заданного матрицей смежности.

    Параметры:
        n: int — число вершин графа
        adjacency_matrix: List[List[int]] — матрица смежности (0/1)
        a: int — стартовая вершина (индекс от 0 до n-1)

    Возвращает:
        T: set — множество прямых рёбер (рёбер BFS-дерева)
        B: set — множество обратных рёбер
        Dnum: dict — глубинные номера вершин в порядке их посещения
    """
    assert n > 0
    assert 0 <= a and a < n
    assert n == len(adjacency_matrix)
    assert all([n == len(r) for r in adjacency_matrix])
    assert all([adjacency_matrix[i][i] == 0 for i in range(n)])
    assert all([
        all([adjacency_matrix[i][j] == adjacency_matrix[j][i] for j in range(n)])
        for i in range(n)
    ])
    
    # ------- Шаг 1: инициализация -------
    Q = deque()                 # Очередь открытых вершин
    T = set()                   # Множество прямых рёбер (BFS-дерево)
    B = set()                   # Множество обратных рёбер
    Dnum = dict()               # Словарь глубинных номеров
    k = 1                       # Счётчик порядка посещения
    Dnum[a] = 1                 # Присвоить стартовой вершине номер 1
    Q.append(a)                 # Добавить стартовую вершину в очередь

    # ------- Основной цикл обхода -------
    while len(Q) != 0:
        # ------- Шаг 2: извлечение активной вершины -------
        x = Q.popleft()         # x становится активной вершиной

        # ------- Шаг 3: перебор всех смежных вершин -------
        for y in range(n):
            # Пропустить, если нет ребра между x и y
            if adjacency_matrix[x][y] == 0:
                continue

            # Нормализуем ребро
            e = (min(x, y), max(x, y))

            # Пропустить, если ребро уже было обработано (уже в T или B)
            if e in T or e in B:
                continue

            # ------- Шаг 4: классификация ребра -------
            if y in Dnum:
                # y уже была посещена → ребро (x, y) — обратное
                B.add(e)
            else:
                # y — новая вершина → ребро (x, y) — прямое
                T.add(e)                # Добавить в каркас
                Q.append(y)             # Открыть вершину y
                k += 1                  # Увеличить счётчик посещений
                Dnum[y] = k             # Присвоить глубинный номер

        # После обработки всех рёбер при x, x становится закрытой.
        # Цикл автоматически переходит к следующей вершине в очереди (Шаг 2).

    # Конец алгоритма
    return T, B, Dnum